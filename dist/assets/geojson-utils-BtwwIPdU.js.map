{"version":3,"file":"geojson-utils-BtwwIPdU.js","sources":["../../node_modules/@tmcw/togeojson/dist/togeojson.es.mjs"],"sourcesContent":["function $(element, tagName) {\n    return Array.from(element.getElementsByTagName(tagName));\n}\nfunction normalizeId(id) {\n    return id[0] === \"#\" ? id : `#${id}`;\n}\nfunction $ns(element, tagName, ns) {\n    return Array.from(element.getElementsByTagNameNS(ns, tagName));\n}\n/**\n * get the content of a text node, if any\n */\nfunction nodeVal(node) {\n    node?.normalize();\n    return node?.textContent || \"\";\n}\n/**\n * Get one Y child of X, if any, otherwise null\n */\nfunction get1(node, tagName, callback) {\n    const n = node.getElementsByTagName(tagName);\n    const result = n.length ? n[0] : null;\n    if (result && callback)\n        callback(result);\n    return result;\n}\nfunction get(node, tagName, callback) {\n    const properties = {};\n    if (!node)\n        return properties;\n    const n = node.getElementsByTagName(tagName);\n    const result = n.length ? n[0] : null;\n    if (result && callback) {\n        return callback(result, properties);\n    }\n    return properties;\n}\nfunction val1(node, tagName, callback) {\n    const val = nodeVal(get1(node, tagName));\n    if (val && callback)\n        return callback(val) || {};\n    return {};\n}\nfunction $num(node, tagName, callback) {\n    const val = Number.parseFloat(nodeVal(get1(node, tagName)));\n    if (Number.isNaN(val))\n        return undefined;\n    if (val && callback)\n        return callback(val) || {};\n    return {};\n}\nfunction num1(node, tagName, callback) {\n    const val = Number.parseFloat(nodeVal(get1(node, tagName)));\n    if (Number.isNaN(val))\n        return undefined;\n    if (callback)\n        callback(val);\n    return val;\n}\nfunction getMulti(node, propertyNames) {\n    const properties = {};\n    for (const property of propertyNames) {\n        val1(node, property, (val) => {\n            properties[property] = val;\n        });\n    }\n    return properties;\n}\nfunction isElement(node) {\n    return node?.nodeType === 1;\n}\n\nfunction getExtensions(node) {\n    let values = [];\n    if (node === null)\n        return values;\n    for (const child of Array.from(node.childNodes)) {\n        if (!isElement(child))\n            continue;\n        const name = abbreviateName(child.nodeName);\n        if (name === \"gpxtpx:TrackPointExtension\") {\n            // loop again for nested garmin extensions (eg. \"gpxtpx:hr\")\n            values = values.concat(getExtensions(child));\n        }\n        else {\n            // push custom extension (eg. \"power\")\n            const val = nodeVal(child);\n            values.push([name, parseNumeric(val)]);\n        }\n    }\n    return values;\n}\nfunction abbreviateName(name) {\n    return [\"heart\", \"gpxtpx:hr\", \"hr\"].includes(name) ? \"heart\" : name;\n}\nfunction parseNumeric(val) {\n    const num = Number.parseFloat(val);\n    return Number.isNaN(num) ? val : num;\n}\n\nfunction coordPair$1(node) {\n    const ll = [\n        Number.parseFloat(node.getAttribute(\"lon\") || \"\"),\n        Number.parseFloat(node.getAttribute(\"lat\") || \"\"),\n    ];\n    if (Number.isNaN(ll[0]) || Number.isNaN(ll[1])) {\n        return null;\n    }\n    num1(node, \"ele\", (val) => {\n        ll.push(val);\n    });\n    const time = get1(node, \"time\");\n    return {\n        coordinates: ll,\n        time: time ? nodeVal(time) : null,\n        extendedValues: getExtensions(get1(node, \"extensions\")),\n    };\n}\n\nfunction getLineStyle(node) {\n    return get(node, \"line\", (lineStyle) => {\n        const val = Object.assign({}, val1(lineStyle, \"color\", (color) => {\n            return { stroke: `#${color}` };\n        }), $num(lineStyle, \"opacity\", (opacity) => {\n            return { \"stroke-opacity\": opacity };\n        }), $num(lineStyle, \"width\", (width) => {\n            // GPX width is in mm, convert to px with 96 px per inch\n            return { \"stroke-width\": (width * 96) / 25.4 };\n        }));\n        return val;\n    });\n}\n\nfunction extractProperties(ns, node) {\n    const properties = getMulti(node, [\n        \"name\",\n        \"cmt\",\n        \"desc\",\n        \"type\",\n        \"time\",\n        \"keywords\",\n    ]);\n    for (const [n, url] of ns) {\n        for (const child of Array.from(node.getElementsByTagNameNS(url, \"*\"))) {\n            properties[child.tagName.replace(\":\", \"_\")] = nodeVal(child)?.trim();\n        }\n    }\n    const links = $(node, \"link\");\n    if (links.length) {\n        properties.links = links.map((link) => Object.assign({ href: link.getAttribute(\"href\") }, getMulti(link, [\"text\", \"type\"])));\n    }\n    return properties;\n}\n\n/**\n * Extract points from a trkseg or rte element.\n */\nfunction getPoints$1(node, pointname) {\n    const pts = $(node, pointname);\n    const line = [];\n    const times = [];\n    const extendedValues = {};\n    for (let i = 0; i < pts.length; i++) {\n        const c = coordPair$1(pts[i]);\n        if (!c) {\n            continue;\n        }\n        line.push(c.coordinates);\n        if (c.time)\n            times.push(c.time);\n        for (const [name, val] of c.extendedValues) {\n            const plural = name === \"heart\" ? name : `${name.replace(\"gpxtpx:\", \"\")}s`;\n            if (!extendedValues[plural]) {\n                extendedValues[plural] = Array(pts.length).fill(null);\n            }\n            extendedValues[plural][i] = val;\n        }\n    }\n    if (line.length < 2)\n        return; // Invalid line in GeoJSON\n    return {\n        line: line,\n        times: times,\n        extendedValues: extendedValues,\n    };\n}\n/**\n * Extract a LineString geometry from a rte\n * element.\n */\nfunction getRoute(ns, node) {\n    const line = getPoints$1(node, \"rtept\");\n    if (!line)\n        return;\n    return {\n        type: \"Feature\",\n        properties: Object.assign({ _gpxType: \"rte\" }, extractProperties(ns, node), getLineStyle(get1(node, \"extensions\"))),\n        geometry: {\n            type: \"LineString\",\n            coordinates: line.line,\n        },\n    };\n}\nfunction getTrack(ns, node) {\n    const segments = $(node, \"trkseg\");\n    const track = [];\n    const times = [];\n    const extractedLines = [];\n    for (const segment of segments) {\n        const line = getPoints$1(segment, \"trkpt\");\n        if (line) {\n            extractedLines.push(line);\n            if (line.times?.length)\n                times.push(line.times);\n        }\n    }\n    if (extractedLines.length === 0)\n        return null;\n    const multi = extractedLines.length > 1;\n    const properties = Object.assign({ _gpxType: \"trk\" }, extractProperties(ns, node), getLineStyle(get1(node, \"extensions\")), times.length\n        ? {\n            coordinateProperties: {\n                times: multi ? times : times[0],\n            },\n        }\n        : {});\n    for (let i = 0; i < extractedLines.length; i++) {\n        const line = extractedLines[i];\n        track.push(line.line);\n        if (!properties.coordinateProperties) {\n            properties.coordinateProperties = {};\n        }\n        const props = properties.coordinateProperties;\n        // Generally extendedValues will be things like heart\n        // rate, and this is an array like { heart: [100, 101...] }\n        for (const [name, val] of Object.entries(line.extendedValues)) {\n            if (multi) {\n                if (!props[name]) {\n                    props[name] = extractedLines.map((line) => new Array(line.line.length).fill(null));\n                }\n                props[name][i] = val;\n            }\n            else {\n                props[name] = val;\n            }\n        }\n    }\n    return {\n        type: \"Feature\",\n        properties: properties,\n        geometry: multi\n            ? {\n                type: \"MultiLineString\",\n                coordinates: track,\n            }\n            : {\n                type: \"LineString\",\n                coordinates: track[0],\n            },\n    };\n}\n/**\n * Extract a point, if possible, from a given node,\n * which is usually a wpt or trkpt\n */\nfunction getPoint(ns, node) {\n    const properties = Object.assign(extractProperties(ns, node), getMulti(node, [\"sym\"]));\n    const pair = coordPair$1(node);\n    if (!pair)\n        return null;\n    return {\n        type: \"Feature\",\n        properties,\n        geometry: {\n            type: \"Point\",\n            coordinates: pair.coordinates,\n        },\n    };\n}\n/**\n * Convert GPX to GeoJSON incrementally, returning\n * a [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n * that yields output feature by feature.\n */\nfunction* gpxGen(node) {\n    const n = node;\n    const GPXX = \"gpxx\";\n    const GPXX_URI = \"http://www.garmin.com/xmlschemas/GpxExtensions/v3\";\n    // Namespaces\n    const ns = [[GPXX, GPXX_URI]];\n    const attrs = n.getElementsByTagName(\"gpx\")[0]?.attributes;\n    if (attrs) {\n        for (const attr of Array.from(attrs)) {\n            if (attr.name?.startsWith(\"xmlns:\") && attr.value !== GPXX_URI) {\n                ns.push([attr.name, attr.value]);\n            }\n        }\n    }\n    for (const track of $(n, \"trk\")) {\n        const feature = getTrack(ns, track);\n        if (feature)\n            yield feature;\n    }\n    for (const route of $(n, \"rte\")) {\n        const feature = getRoute(ns, route);\n        if (feature)\n            yield feature;\n    }\n    for (const waypoint of $(n, \"wpt\")) {\n        const point = getPoint(ns, waypoint);\n        if (point)\n            yield point;\n    }\n}\n/**\n *\n * Convert a GPX document to GeoJSON. The first argument, `doc`, must be a GPX\n * document as an XML DOM - not as a string. You can get this using jQuery's default\n * `.ajax` function or using a bare XMLHttpRequest with the `.response` property\n * holding an XML DOM.\n *\n * The output is a JavaScript object of GeoJSON data, same as `.kml` outputs, with the\n * addition of a `_gpxType` property on each `LineString` feature that indicates whether\n * the feature was encoded as a route (`rte`) or track (`trk`) in the GPX document.\n */\nfunction gpx(node) {\n    return {\n        type: \"FeatureCollection\",\n        features: Array.from(gpxGen(node)),\n    };\n}\n\nconst EXTENSIONS_NS = \"http://www.garmin.com/xmlschemas/ActivityExtension/v2\";\nconst TRACKPOINT_ATTRIBUTES = [\n    [\"heartRate\", \"heartRates\"],\n    [\"Cadence\", \"cadences\"],\n    // Extended Trackpoint attributes\n    [\"Speed\", \"speeds\"],\n    [\"Watts\", \"watts\"],\n];\nconst LAP_ATTRIBUTES = [\n    [\"TotalTimeSeconds\", \"totalTimeSeconds\"],\n    [\"DistanceMeters\", \"distanceMeters\"],\n    [\"MaximumSpeed\", \"maxSpeed\"],\n    [\"AverageHeartRateBpm\", \"avgHeartRate\"],\n    [\"MaximumHeartRateBpm\", \"maxHeartRate\"],\n    // Extended Lap attributes\n    [\"AvgSpeed\", \"avgSpeed\"],\n    [\"AvgWatts\", \"avgWatts\"],\n    [\"MaxWatts\", \"maxWatts\"],\n];\nfunction getProperties(node, attributeNames) {\n    const properties = [];\n    for (const [tag, alias] of attributeNames) {\n        let elem = get1(node, tag);\n        if (!elem) {\n            const elements = node.getElementsByTagNameNS(EXTENSIONS_NS, tag);\n            if (elements.length) {\n                elem = elements[0];\n            }\n        }\n        const val = Number.parseFloat(nodeVal(elem));\n        if (!Number.isNaN(val)) {\n            properties.push([alias, val]);\n        }\n    }\n    return properties;\n}\nfunction coordPair(node) {\n    const ll = [num1(node, \"LongitudeDegrees\"), num1(node, \"LatitudeDegrees\")];\n    if (ll[0] === undefined ||\n        Number.isNaN(ll[0]) ||\n        ll[1] === undefined ||\n        Number.isNaN(ll[1])) {\n        return null;\n    }\n    const heartRate = get1(node, \"HeartRateBpm\");\n    const time = nodeVal(get1(node, \"Time\"));\n    get1(node, \"AltitudeMeters\", (alt) => {\n        const a = Number.parseFloat(nodeVal(alt));\n        if (!Number.isNaN(a)) {\n            ll.push(a);\n        }\n    });\n    return {\n        coordinates: ll,\n        time: time || null,\n        heartRate: heartRate ? Number.parseFloat(nodeVal(heartRate)) : null,\n        extensions: getProperties(node, TRACKPOINT_ATTRIBUTES),\n    };\n}\nfunction getPoints(node) {\n    const pts = $(node, \"Trackpoint\");\n    const line = [];\n    const times = [];\n    const heartRates = [];\n    if (pts.length < 2)\n        return null; // Invalid line in GeoJSON\n    const extendedProperties = {};\n    const result = { extendedProperties };\n    for (let i = 0; i < pts.length; i++) {\n        const c = coordPair(pts[i]);\n        if (c === null)\n            continue;\n        line.push(c.coordinates);\n        const { time, heartRate, extensions } = c;\n        if (time)\n            times.push(time);\n        if (heartRate)\n            heartRates.push(heartRate);\n        for (const [alias, value] of extensions) {\n            if (!extendedProperties[alias]) {\n                extendedProperties[alias] = Array(pts.length).fill(null);\n            }\n            extendedProperties[alias][i] = value;\n        }\n    }\n    if (line.length < 2)\n        return null;\n    return Object.assign(result, {\n        line: line,\n        times: times,\n        heartRates: heartRates,\n    });\n}\nfunction getLap(node) {\n    const segments = $(node, \"Track\");\n    const track = [];\n    const times = [];\n    const heartRates = [];\n    const allExtendedProperties = [];\n    let line;\n    const properties = Object.assign(Object.fromEntries(getProperties(node, LAP_ATTRIBUTES)), get(node, \"Name\", (nameElement) => {\n        return { name: nodeVal(nameElement) };\n    }));\n    for (const segment of segments) {\n        line = getPoints(segment);\n        if (line) {\n            track.push(line.line);\n            if (line.times.length)\n                times.push(line.times);\n            if (line.heartRates.length)\n                heartRates.push(line.heartRates);\n            allExtendedProperties.push(line.extendedProperties);\n        }\n    }\n    for (let i = 0; i < allExtendedProperties.length; i++) {\n        const extendedProperties = allExtendedProperties[i];\n        for (const property in extendedProperties) {\n            if (segments.length === 1) {\n                if (line) {\n                    properties[property] = line.extendedProperties[property];\n                }\n            }\n            else {\n                if (!properties[property]) {\n                    properties[property] = track.map((track) => Array(track.length).fill(null));\n                }\n                properties[property][i] = extendedProperties[property];\n            }\n        }\n    }\n    if (track.length === 0)\n        return null;\n    if (times.length || heartRates.length) {\n        properties.coordinateProperties = Object.assign(times.length\n            ? {\n                times: track.length === 1 ? times[0] : times,\n            }\n            : {}, heartRates.length\n            ? {\n                heart: track.length === 1 ? heartRates[0] : heartRates,\n            }\n            : {});\n    }\n    return {\n        type: \"Feature\",\n        properties: properties,\n        geometry: track.length === 1\n            ? {\n                type: \"LineString\",\n                coordinates: track[0],\n            }\n            : {\n                type: \"MultiLineString\",\n                coordinates: track,\n            },\n    };\n}\n/**\n * Incrementally convert a TCX document to GeoJSON. The\n * first argument, `doc`, must be a TCX\n * document as an XML DOM - not as a string.\n */\nfunction* tcxGen(node) {\n    for (const lap of $(node, \"Lap\")) {\n        const feature = getLap(lap);\n        if (feature)\n            yield feature;\n    }\n    for (const course of $(node, \"Courses\")) {\n        const feature = getLap(course);\n        if (feature)\n            yield feature;\n    }\n}\n/**\n * Convert a TCX document to GeoJSON. The first argument, `doc`, must be a TCX\n * document as an XML DOM - not as a string.\n */\nfunction tcx(node) {\n    return {\n        type: \"FeatureCollection\",\n        features: Array.from(tcxGen(node)),\n    };\n}\n\nfunction fixColor(v, prefix) {\n    const properties = {};\n    const colorProp = prefix === \"stroke\" || prefix === \"fill\" ? prefix : `${prefix}-color`;\n    if (v[0] === \"#\") {\n        v = v.substring(1);\n    }\n    if (v.length === 6 || v.length === 3) {\n        properties[colorProp] = `#${v}`;\n    }\n    else if (v.length === 8) {\n        properties[`${prefix}-opacity`] =\n            Number.parseInt(v.substring(0, 2), 16) / 255;\n        properties[colorProp] =\n            `#${v.substring(6, 8)}${v.substring(4, 6)}${v.substring(2, 4)}`;\n    }\n    return properties;\n}\n\nfunction numericProperty(node, source, target) {\n    const properties = {};\n    num1(node, source, (val) => {\n        properties[target] = val;\n    });\n    return properties;\n}\nfunction getColor(node, output) {\n    return get(node, \"color\", (elem) => fixColor(nodeVal(elem), output));\n}\nfunction extractIconHref(node) {\n    return get(node, \"Icon\", (icon, properties) => {\n        val1(icon, \"href\", (href) => {\n            properties.icon = href;\n        });\n        return properties;\n    });\n}\nfunction extractIcon(node) {\n    return get(node, \"IconStyle\", (iconStyle) => {\n        return Object.assign(getColor(iconStyle, \"icon\"), numericProperty(iconStyle, \"scale\", \"icon-scale\"), numericProperty(iconStyle, \"heading\", \"icon-heading\"), get(iconStyle, \"hotSpot\", (hotspot) => {\n            const left = Number.parseFloat(hotspot.getAttribute(\"x\") || \"\");\n            const top = Number.parseFloat(hotspot.getAttribute(\"y\") || \"\");\n            const xunits = hotspot.getAttribute(\"xunits\") || \"\";\n            const yunits = hotspot.getAttribute(\"yunits\") || \"\";\n            if (!Number.isNaN(left) && !Number.isNaN(top))\n                return {\n                    \"icon-offset\": [left, top],\n                    \"icon-offset-units\": [xunits, yunits],\n                };\n            return {};\n        }), extractIconHref(iconStyle));\n    });\n}\nfunction extractLabel(node) {\n    return get(node, \"LabelStyle\", (labelStyle) => {\n        return Object.assign(getColor(labelStyle, \"label\"), numericProperty(labelStyle, \"scale\", \"label-scale\"));\n    });\n}\nfunction extractLine(node) {\n    return get(node, \"LineStyle\", (lineStyle) => {\n        return Object.assign(getColor(lineStyle, \"stroke\"), numericProperty(lineStyle, \"width\", \"stroke-width\"));\n    });\n}\nfunction extractPoly(node) {\n    return get(node, \"PolyStyle\", (polyStyle, properties) => {\n        return Object.assign(properties, get(polyStyle, \"color\", (elem) => fixColor(nodeVal(elem), \"fill\")), val1(polyStyle, \"fill\", (fill) => {\n            if (fill === \"0\")\n                return { \"fill-opacity\": 0 };\n        }), val1(polyStyle, \"outline\", (outline) => {\n            if (outline === \"0\")\n                return { \"stroke-opacity\": 0 };\n        }));\n    });\n}\nfunction extractStyle(node) {\n    return Object.assign({}, extractPoly(node), extractLine(node), extractLabel(node), extractIcon(node));\n}\n\nconst removeSpace = /\\s*/g;\nconst trimSpace = /^\\s*|\\s*$/g;\nconst splitSpace = /\\s+/;\n/**\n * Get one coordinate from a coordinate array, if any\n */\nfunction coord1(value) {\n    return value\n        .replace(removeSpace, \"\")\n        .split(\",\")\n        .map(Number.parseFloat)\n        .filter((num) => !Number.isNaN(num))\n        .slice(0, 3);\n}\n/**\n * Get all coordinates from a coordinate array as [[],[]]\n */\nfunction coord(value) {\n    return value\n        .replace(trimSpace, \"\")\n        .split(splitSpace)\n        .map(coord1)\n        .filter((coord) => {\n        return coord.length >= 2;\n    });\n}\nfunction gxCoords(node) {\n    let elems = $(node, \"coord\");\n    if (elems.length === 0) {\n        elems = $ns(node, \"coord\", \"*\");\n    }\n    const coordinates = elems.map((elem) => {\n        return nodeVal(elem).split(\" \").map(Number.parseFloat);\n    });\n    if (coordinates.length === 0) {\n        return null;\n    }\n    return {\n        geometry: coordinates.length > 2\n            ? {\n                type: \"LineString\",\n                coordinates,\n            }\n            : {\n                type: \"Point\",\n                coordinates: coordinates[0],\n            },\n        times: $(node, \"when\").map((elem) => nodeVal(elem)),\n    };\n}\nfunction fixRing(ring) {\n    if (ring.length === 0)\n        return ring;\n    const first = ring[0];\n    const last = ring[ring.length - 1];\n    let equal = true;\n    for (let i = 0; i < Math.max(first.length, last.length); i++) {\n        if (first[i] !== last[i]) {\n            equal = false;\n            break;\n        }\n    }\n    if (!equal) {\n        return ring.concat([ring[0]]);\n    }\n    return ring;\n}\nfunction getCoordinates(node) {\n    return nodeVal(get1(node, \"coordinates\"));\n}\nfunction getGeometry(node) {\n    let geometries = [];\n    let coordTimes = [];\n    for (let i = 0; i < node.childNodes.length; i++) {\n        const child = node.childNodes.item(i);\n        if (isElement(child)) {\n            switch (child.tagName) {\n                case \"MultiGeometry\":\n                case \"MultiTrack\":\n                case \"gx:MultiTrack\": {\n                    const childGeometries = getGeometry(child);\n                    geometries = geometries.concat(childGeometries.geometries);\n                    coordTimes = coordTimes.concat(childGeometries.coordTimes);\n                    break;\n                }\n                case \"Point\": {\n                    const coordinates = coord1(getCoordinates(child));\n                    if (coordinates.length >= 2) {\n                        geometries.push({\n                            type: \"Point\",\n                            coordinates,\n                        });\n                    }\n                    break;\n                }\n                case \"LinearRing\":\n                case \"LineString\": {\n                    const coordinates = coord(getCoordinates(child));\n                    if (coordinates.length >= 2) {\n                        geometries.push({\n                            type: \"LineString\",\n                            coordinates,\n                        });\n                    }\n                    break;\n                }\n                case \"Polygon\": {\n                    const coords = [];\n                    for (const linearRing of $(child, \"LinearRing\")) {\n                        const ring = fixRing(coord(getCoordinates(linearRing)));\n                        if (ring.length >= 4) {\n                            coords.push(ring);\n                        }\n                    }\n                    if (coords.length) {\n                        geometries.push({\n                            type: \"Polygon\",\n                            coordinates: coords,\n                        });\n                    }\n                    break;\n                }\n                case \"Track\":\n                case \"gx:Track\": {\n                    const gx = gxCoords(child);\n                    if (!gx)\n                        break;\n                    const { times, geometry } = gx;\n                    geometries.push(geometry);\n                    if (times.length)\n                        coordTimes.push(times);\n                    break;\n                }\n            }\n        }\n    }\n    return {\n        geometries,\n        coordTimes,\n    };\n}\n\nconst toNumber = (x) => Number(x);\nconst typeConverters = {\n    string: (x) => x,\n    int: toNumber,\n    uint: toNumber,\n    short: toNumber,\n    ushort: toNumber,\n    float: toNumber,\n    double: toNumber,\n    bool: (x) => Boolean(x),\n};\nfunction extractExtendedData(node, schema) {\n    return get(node, \"ExtendedData\", (extendedData, properties) => {\n        for (const data of $(extendedData, \"Data\")) {\n            properties[data.getAttribute(\"name\") || \"\"] = nodeVal(get1(data, \"value\"));\n        }\n        for (const simpleData of $(extendedData, \"SimpleData\")) {\n            const name = simpleData.getAttribute(\"name\") || \"\";\n            const typeConverter = schema[name] || typeConverters.string;\n            properties[name] = typeConverter(nodeVal(simpleData));\n        }\n        return properties;\n    });\n}\nfunction getMaybeHTMLDescription(node) {\n    const descriptionNode = get1(node, \"description\");\n    for (const c of Array.from(descriptionNode?.childNodes || [])) {\n        if (c.nodeType === 4) {\n            return {\n                description: {\n                    \"@type\": \"html\",\n                    value: nodeVal(c),\n                },\n            };\n        }\n    }\n    return {};\n}\nfunction extractTimeSpan(node) {\n    return get(node, \"TimeSpan\", (timeSpan) => {\n        return {\n            timespan: {\n                begin: nodeVal(get1(timeSpan, \"begin\")),\n                end: nodeVal(get1(timeSpan, \"end\")),\n            },\n        };\n    });\n}\nfunction extractTimeStamp(node) {\n    return get(node, \"TimeStamp\", (timeStamp) => {\n        return { timestamp: nodeVal(get1(timeStamp, \"when\")) };\n    });\n}\nfunction extractCascadedStyle(node, styleMap) {\n    return val1(node, \"styleUrl\", (styleUrl) => {\n        styleUrl = normalizeId(styleUrl);\n        if (styleMap[styleUrl]) {\n            return Object.assign({ styleUrl }, styleMap[styleUrl]);\n        }\n        // For backward-compatibility. Should we still include\n        // styleUrl even if it's not resolved?\n        return { styleUrl };\n    });\n}\nvar AltitudeMode;\n(function (AltitudeMode) {\n    AltitudeMode[\"ABSOLUTE\"] = \"absolute\";\n    AltitudeMode[\"RELATIVE_TO_GROUND\"] = \"relativeToGround\";\n    AltitudeMode[\"CLAMP_TO_GROUND\"] = \"clampToGround\";\n    AltitudeMode[\"CLAMP_TO_SEAFLOOR\"] = \"clampToSeaFloor\";\n    AltitudeMode[\"RELATIVE_TO_SEAFLOOR\"] = \"relativeToSeaFloor\";\n})(AltitudeMode || (AltitudeMode = {}));\nfunction processAltitudeMode(mode) {\n    switch (mode?.textContent) {\n        case AltitudeMode.ABSOLUTE:\n            return AltitudeMode.ABSOLUTE;\n        case AltitudeMode.CLAMP_TO_GROUND:\n            return AltitudeMode.CLAMP_TO_GROUND;\n        case AltitudeMode.CLAMP_TO_SEAFLOOR:\n            return AltitudeMode.CLAMP_TO_SEAFLOOR;\n        case AltitudeMode.RELATIVE_TO_GROUND:\n            return AltitudeMode.RELATIVE_TO_GROUND;\n        case AltitudeMode.RELATIVE_TO_SEAFLOOR:\n            return AltitudeMode.RELATIVE_TO_SEAFLOOR;\n    }\n    return null;\n}\n\nfunction getGroundOverlayBox(node) {\n    const latLonQuad = get1(node, \"gx:LatLonQuad\");\n    if (latLonQuad) {\n        const ring = fixRing(coord(getCoordinates(node)));\n        return {\n            geometry: {\n                type: \"Polygon\",\n                coordinates: [ring],\n            },\n        };\n    }\n    return getLatLonBox(node);\n}\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nfunction rotateBox(bbox, coordinates, rotation) {\n    const center = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];\n    return [\n        coordinates[0].map((coordinate) => {\n            const dy = coordinate[1] - center[1];\n            const dx = coordinate[0] - center[0];\n            const distance = Math.sqrt(dy ** 2 + dx ** 2);\n            const angle = Math.atan2(dy, dx) + rotation * DEGREES_TO_RADIANS;\n            return [\n                center[0] + Math.cos(angle) * distance,\n                center[1] + Math.sin(angle) * distance,\n            ];\n        }),\n    ];\n}\nfunction getLatLonBox(node) {\n    const latLonBox = get1(node, \"LatLonBox\");\n    if (latLonBox) {\n        const north = num1(latLonBox, \"north\");\n        const west = num1(latLonBox, \"west\");\n        const east = num1(latLonBox, \"east\");\n        const south = num1(latLonBox, \"south\");\n        const rotation = num1(latLonBox, \"rotation\");\n        if (typeof north === \"number\" &&\n            typeof south === \"number\" &&\n            typeof west === \"number\" &&\n            typeof east === \"number\") {\n            const bbox = [west, south, east, north];\n            let coordinates = [\n                [\n                    [west, north], // top left\n                    [east, north], // top right\n                    [east, south], // top right\n                    [west, south], // bottom left\n                    [west, north], // top left (again)\n                ],\n            ];\n            if (typeof rotation === \"number\") {\n                coordinates = rotateBox(bbox, coordinates, rotation);\n            }\n            return {\n                bbox,\n                geometry: {\n                    type: \"Polygon\",\n                    coordinates,\n                },\n            };\n        }\n    }\n    return null;\n}\nfunction getGroundOverlay(node, styleMap, schema, options) {\n    const box = getGroundOverlayBox(node);\n    const geometry = box?.geometry || null;\n    if (!geometry && options.skipNullGeometry) {\n        return null;\n    }\n    const feature = {\n        type: \"Feature\",\n        geometry,\n        properties: Object.assign(\n        /**\n         * Related to\n         * https://gist.github.com/tmcw/037a1cb6660d74a392e9da7446540f46\n         */\n        { \"@geometry-type\": \"groundoverlay\" }, getMulti(node, [\n            \"name\",\n            \"address\",\n            \"visibility\",\n            \"open\",\n            \"phoneNumber\",\n            \"description\",\n        ]), getMaybeHTMLDescription(node), extractCascadedStyle(node, styleMap), extractStyle(node), extractIconHref(node), extractExtendedData(node, schema), extractTimeSpan(node), extractTimeStamp(node)),\n    };\n    if (box?.bbox) {\n        feature.bbox = box.bbox;\n    }\n    if (feature.properties?.visibility !== undefined) {\n        feature.properties.visibility = feature.properties.visibility !== \"0\";\n    }\n    const id = node.getAttribute(\"id\");\n    if (id !== null && id !== \"\")\n        feature.id = id;\n    return feature;\n}\n\nfunction getNetworkLinkRegion(node) {\n    const region = get1(node, \"Region\");\n    if (region) {\n        return {\n            coordinateBox: getLatLonAltBox(region),\n            lod: getLod(node),\n        };\n    }\n    return null;\n}\nfunction getLod(node) {\n    const lod = get1(node, \"Lod\");\n    if (lod) {\n        return [\n            num1(lod, \"minLodPixels\") ?? -1,\n            num1(lod, \"maxLodPixels\") ?? -1,\n            num1(lod, \"minFadeExtent\") ?? null,\n            num1(lod, \"maxFadeExtent\") ?? null,\n        ];\n    }\n    return null;\n}\nfunction getLatLonAltBox(node) {\n    const latLonAltBox = get1(node, \"LatLonAltBox\");\n    if (latLonAltBox) {\n        const north = num1(latLonAltBox, \"north\");\n        const west = num1(latLonAltBox, \"west\");\n        const east = num1(latLonAltBox, \"east\");\n        const south = num1(latLonAltBox, \"south\");\n        const altitudeMode = processAltitudeMode(get1(latLonAltBox, \"altitudeMode\") ||\n            get1(latLonAltBox, \"gx:altitudeMode\"));\n        if (altitudeMode) {\n            console.debug(\"Encountered an unsupported feature of KML for togeojson: please contact developers for support of altitude mode.\");\n        }\n        if (typeof north === \"number\" &&\n            typeof south === \"number\" &&\n            typeof west === \"number\" &&\n            typeof east === \"number\") {\n            const bbox = [west, south, east, north];\n            const coordinates = [\n                [\n                    [west, north], // top left\n                    [east, north], // top right\n                    [east, south], // top right\n                    [west, south], // bottom left\n                    [west, north], // top left (again)\n                ],\n            ];\n            return {\n                bbox,\n                geometry: {\n                    type: \"Polygon\",\n                    coordinates,\n                },\n            };\n        }\n    }\n    return null;\n}\nfunction getLinkObject(node) {\n    /*\n      <Link id=\"ID\">\n        <!-- specific to Link -->\n        <href>...</href>                      <!-- string -->\n        <refreshMode>onChange</refreshMode>\n          <!-- refreshModeEnum: onChange, onInterval, or onExpire -->\n        <refreshInterval>4</refreshInterval>  <!-- float -->\n        <viewRefreshMode>never</viewRefreshMode>\n          <!-- viewRefreshModeEnum: never, onStop, onRequest, onRegion -->\n        <viewRefreshTime>4</viewRefreshTime>  <!-- float -->\n        <viewBoundScale>1</viewBoundScale>    <!-- float -->\n        <viewFormat>BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]</viewFormat>\n                                              <!-- string -->\n        <httpQuery>...</httpQuery>            <!-- string -->\n      </Link>\n    */\n    const linkObj = get1(node, \"Link\");\n    if (linkObj) {\n        return getMulti(linkObj, [\n            \"href\",\n            \"refreshMode\",\n            \"refreshInterval\",\n            \"viewRefreshMode\",\n            \"viewRefreshTime\",\n            \"viewBoundScale\",\n            \"viewFormat\",\n            \"httpQuery\",\n        ]);\n    }\n    return {};\n}\nfunction getNetworkLink(node, styleMap, schema, options) {\n    const box = getNetworkLinkRegion(node);\n    const geometry = box?.coordinateBox?.geometry || null;\n    if (!geometry && options.skipNullGeometry) {\n        return null;\n    }\n    const feature = {\n        type: \"Feature\",\n        geometry,\n        properties: Object.assign(\n        /**\n         * Related to\n         * https://gist.github.com/tmcw/037a1cb6660d74a392e9da7446540f46\n         */\n        { \"@geometry-type\": \"networklink\" }, getMulti(node, [\n            \"name\",\n            \"address\",\n            \"visibility\",\n            \"open\",\n            \"phoneNumber\",\n            \"styleUrl\",\n            \"refreshVisibility\",\n            \"flyToView\",\n            \"description\",\n        ]), getMaybeHTMLDescription(node), extractCascadedStyle(node, styleMap), extractStyle(node), extractIconHref(node), extractExtendedData(node, schema), extractTimeSpan(node), extractTimeStamp(node), getLinkObject(node), box?.lod ? { lod: box.lod } : {}),\n    };\n    if (box?.coordinateBox?.bbox) {\n        feature.bbox = box.coordinateBox.bbox;\n    }\n    if (feature.properties?.visibility !== undefined) {\n        feature.properties.visibility = feature.properties.visibility !== \"0\";\n    }\n    const id = node.getAttribute(\"id\");\n    if (id !== null && id !== \"\")\n        feature.id = id;\n    return feature;\n}\n\nfunction geometryListToGeometry(geometries) {\n    return geometries.length === 0\n        ? null\n        : geometries.length === 1\n            ? geometries[0]\n            : {\n                type: \"GeometryCollection\",\n                geometries,\n            };\n}\nfunction getPlacemark(node, styleMap, schema, options) {\n    const { coordTimes, geometries } = getGeometry(node);\n    const geometry = geometryListToGeometry(geometries);\n    if (!geometry && options.skipNullGeometry) {\n        return null;\n    }\n    const feature = {\n        type: \"Feature\",\n        geometry,\n        properties: Object.assign(getMulti(node, [\n            \"name\",\n            \"address\",\n            \"visibility\",\n            \"open\",\n            \"phoneNumber\",\n            \"description\",\n        ]), getMaybeHTMLDescription(node), extractCascadedStyle(node, styleMap), extractStyle(node), extractExtendedData(node, schema), extractTimeSpan(node), extractTimeStamp(node), coordTimes.length\n            ? {\n                coordinateProperties: {\n                    times: coordTimes.length === 1 ? coordTimes[0] : coordTimes,\n                },\n            }\n            : {}),\n    };\n    if (feature.properties?.visibility !== undefined) {\n        feature.properties.visibility = feature.properties.visibility !== \"0\";\n    }\n    const id = node.getAttribute(\"id\");\n    if (id !== null && id !== \"\")\n        feature.id = id;\n    return feature;\n}\n\nfunction getStyleId(style) {\n    let id = style.getAttribute(\"id\");\n    const parentNode = style.parentNode;\n    if (!id &&\n        isElement(parentNode) &&\n        parentNode.localName === \"CascadingStyle\") {\n        id = parentNode.getAttribute(\"kml:id\") || parentNode.getAttribute(\"id\");\n    }\n    return normalizeId(id || \"\");\n}\nfunction buildStyleMap(node) {\n    const styleMap = {};\n    for (const style of $(node, \"Style\")) {\n        styleMap[getStyleId(style)] = extractStyle(style);\n    }\n    for (const map of $(node, \"StyleMap\")) {\n        const id = normalizeId(map.getAttribute(\"id\") || \"\");\n        val1(map, \"styleUrl\", (styleUrl) => {\n            styleUrl = normalizeId(styleUrl);\n            if (styleMap[styleUrl]) {\n                styleMap[id] = styleMap[styleUrl];\n            }\n        });\n    }\n    return styleMap;\n}\nfunction buildSchema(node) {\n    const schema = {};\n    for (const field of $(node, \"SimpleField\")) {\n        schema[field.getAttribute(\"name\") || \"\"] =\n            typeConverters[field.getAttribute(\"type\") || \"\"] || typeConverters.string;\n    }\n    return schema;\n}\nconst FOLDER_PROPS = [\n    \"name\",\n    \"visibility\",\n    \"open\",\n    \"address\",\n    \"description\",\n    \"phoneNumber\",\n    \"visibility\",\n];\nfunction getFolder(node) {\n    const meta = {};\n    for (const child of Array.from(node.childNodes)) {\n        if (isElement(child) && FOLDER_PROPS.includes(child.tagName)) {\n            meta[child.tagName] = nodeVal(child);\n        }\n    }\n    return {\n        type: \"folder\",\n        meta,\n        children: [],\n    };\n}\n/**\n * Yield a nested tree with KML folder structure\n *\n * This generates a tree with the given structure:\n *\n * ```js\n * {\n *   \"type\": \"root\",\n *   \"children\": [\n *     {\n *       \"type\": \"folder\",\n *       \"meta\": {\n *         \"name\": \"Test\"\n *       },\n *       \"children\": [\n *          // ...features and folders\n *       ]\n *     }\n *     // ...features\n *   ]\n * }\n * ```\n *\n * ### GroundOverlay\n *\n * GroundOverlay elements are converted into\n * `Feature` objects with `Polygon` geometries,\n * a property like:\n *\n * ```json\n * {\n *   \"@geometry-type\": \"groundoverlay\"\n * }\n * ```\n *\n * And the ground overlay's image URL in the `href`\n * property. Ground overlays will need to be displayed\n * with a separate method to other features, depending\n * on which map framework you're using.\n */\nfunction kmlWithFolders(node, options = {\n    skipNullGeometry: false,\n}) {\n    const n = node;\n    const styleMap = buildStyleMap(n);\n    const schema = buildSchema(n);\n    const tree = { type: \"root\", children: [] };\n    function traverse(node, pointer, options) {\n        if (isElement(node)) {\n            switch (node.tagName) {\n                case \"GroundOverlay\": {\n                    const placemark = getGroundOverlay(node, styleMap, schema, options);\n                    if (placemark) {\n                        pointer.children.push(placemark);\n                    }\n                    break;\n                }\n                case \"Placemark\": {\n                    const placemark = getPlacemark(node, styleMap, schema, options);\n                    if (placemark) {\n                        pointer.children.push(placemark);\n                    }\n                    break;\n                }\n                case \"Folder\": {\n                    const folder = getFolder(node);\n                    pointer.children.push(folder);\n                    pointer = folder;\n                    break;\n                }\n                case \"NetworkLink\": {\n                    const networkLink = getNetworkLink(node, styleMap, schema, options);\n                    if (networkLink) {\n                        pointer.children.push(networkLink);\n                    }\n                    break;\n                }\n            }\n        }\n        if (node.childNodes) {\n            for (let i = 0; i < node.childNodes.length; i++) {\n                traverse(node.childNodes[i], pointer, options);\n            }\n        }\n    }\n    traverse(n, tree, options);\n    return tree;\n}\n/**\n * Convert KML to GeoJSON incrementally, returning\n * a [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n * that yields output feature by feature.\n */\nfunction* kmlGen(node, options = {\n    skipNullGeometry: false,\n}) {\n    const n = node;\n    const styleMap = buildStyleMap(n);\n    const schema = buildSchema(n);\n    for (const placemark of $(n, \"Placemark\")) {\n        const feature = getPlacemark(placemark, styleMap, schema, options);\n        if (feature)\n            yield feature;\n    }\n    for (const groundOverlay of $(n, \"GroundOverlay\")) {\n        const feature = getGroundOverlay(groundOverlay, styleMap, schema, options);\n        if (feature)\n            yield feature;\n    }\n    for (const networkLink of $(n, \"NetworkLink\")) {\n        const feature = getNetworkLink(networkLink, styleMap, schema, options);\n        if (feature)\n            yield feature;\n    }\n}\n/**\n * Convert a KML document to GeoJSON. The first argument, `doc`, must be a KML\n * document as an XML DOM - not as a string. You can get this using jQuery's default\n * `.ajax` function or using a bare XMLHttpRequest with the `.response` property\n * holding an XML DOM.\n *\n * The output is a JavaScript object of GeoJSON data. You can convert it to a string\n * with [JSON.stringify](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n * or use it directly in libraries.\n */\nfunction kml(node, options = {\n    skipNullGeometry: false,\n}) {\n    return {\n        type: \"FeatureCollection\",\n        features: Array.from(kmlGen(node, options)),\n    };\n}\n\nexport { gpx, gpxGen, kml, kmlGen, kmlWithFolders, tcx, tcxGen };\n//# sourceMappingURL=togeojson.es.mjs.map\n"],"names":["$","element","tagName","normalizeId","id","$ns","ns","nodeVal","node","get1","callback","n","get","properties","result","val1","val","num1","getMulti","propertyNames","property","isElement","fixColor","v","prefix","colorProp","numericProperty","source","target","getColor","output","elem","extractIconHref","icon","href","extractIcon","iconStyle","hotspot","left","top","xunits","yunits","extractLabel","labelStyle","extractLine","lineStyle","extractPoly","polyStyle","fill","outline","extractStyle","removeSpace","trimSpace","splitSpace","coord1","value","num","coord","gxCoords","elems","coordinates","fixRing","ring","first","last","equal","i","getCoordinates","getGeometry","geometries","coordTimes","child","childGeometries","coords","linearRing","gx","times","geometry","toNumber","x","typeConverters","extractExtendedData","schema","extendedData","data","simpleData","name","typeConverter","getMaybeHTMLDescription","descriptionNode","c","extractTimeSpan","timeSpan","extractTimeStamp","timeStamp","extractCascadedStyle","styleMap","styleUrl","AltitudeMode","processAltitudeMode","mode","getGroundOverlayBox","getLatLonBox","DEGREES_TO_RADIANS","rotateBox","bbox","rotation","center","coordinate","dy","dx","distance","angle","latLonBox","north","west","east","south","getGroundOverlay","options","_a","box","feature","getNetworkLinkRegion","region","getLatLonAltBox","getLod","_b","_c","_d","lod","latLonAltBox","getLinkObject","linkObj","getNetworkLink","geometryListToGeometry","getPlacemark","getStyleId","style","parentNode","buildStyleMap","map","buildSchema","field","kmlGen","placemark","groundOverlay","networkLink","kml"],"mappings":"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","x_google_ignoreList":[0]}