{"version":3,"mappings":"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","names":["getEnvTarget","profile","env","v","controllingGroundTarget","segments","fallbackEnv","t","maxFt","seg","asNumber","createPoleProperties","pole","job","props","_a","_b","_c","_d","_e","_f","_g","_h","_i","_j","_k","buildCoordinateIndex","poles","coordIndex","p","lat","lon","buildGeoJSON","input","spans","features","s","a","b","downloadText","filename","text","type","blob","url","exportGeoJSON","fc","exportKML","mod","n","kml","e","exportKMZ","zip","JSZip","exportShapefile","autoDownload","featureCollection","options","shpwrite","loadShpWriteFromCDN","base64","binary","len","bytes","i","cdns","lastError","resolve","reject"],"ignoreList":[],"sources":["../../src/utils/targets.js","../../src/utils/geodata.js"],"sourcesContent":["// Utility helpers for environment-based ground clearance targets\n\n/**\n * Returns the ground clearance target (in feet) for a given environment based on the submission profile.\n * @param {object} profile - Effective submission profile with env*Ft fields\n * @param {string} env - Environment key\n * @returns {number|undefined}\n */\nexport function getEnvTarget(profile, env) {\n  if (!profile || !env) return undefined;\n  const map = {\n    road: profile.envRoadFt,\n    residential: profile.envResidentialFt,\n    pedestrian: profile.envPedestrianFt,\n    field: profile.envFieldFt,\n    residentialYard: profile.envResidentialYardFt,\n    residentialDriveway: profile.envResidentialDrivewayFt,\n    nonResidentialDriveway: profile.envNonResidentialDrivewayFt,\n    waterway: profile.envWaterwayFt,\n    wvHighway: profile.envWVHighwayFt,\n    interstate: profile.envInterstateFt,\n    interstateNewCrossing: profile.envInterstateNewCrossingFt,\n    railroad: profile.envRailroadFt,\n  };\n  const v = map[env];\n  return Number.isFinite(v) ? Number(v) : undefined;\n}\n\n/**\n * Computes the controlling (maximum) ground clearance target across segments.\n * Falls back to the target for the provided fallback environment when segments are empty.\n * @param {object} profile - Effective submission profile\n * @param {Array<{env:string, portion?:number}>} segments - Segment list with environments\n * @param {string} fallbackEnv - Environment to use if no segments provided\n * @returns {number|null}\n */\nexport function controllingGroundTarget(profile, segments, fallbackEnv) {\n  if (!Array.isArray(segments) || !segments.length) {\n    const t = getEnvTarget(profile, fallbackEnv);\n    return Number.isFinite(t) ? Number(t) : null;\n  }\n  let maxFt = 0;\n  for (const seg of segments) {\n    const t = getEnvTarget(profile, seg?.env || fallbackEnv);\n    if (Number.isFinite(t)) maxFt = Math.max(maxFt, Number(t));\n  }\n  return maxFt || null;\n}\n\n/**\n * Gets the controlling target from cached midspans matching the given environment.\n * Falls back to the environment target from the profile if none available.\n * @param {Array<{environment?:string,targetFt?:number}>} cachedMidspans\n * @param {string} env\n * @param {object} profile\n * @returns {number|null}\n */\nexport function maxTargetFromCached(cachedMidspans, env, profile) {\n  const list = Array.isArray(cachedMidspans) ? cachedMidspans : [];\n  const filtered = list.filter((m) => (m?.environment || \"\") === env);\n  let max = -Infinity;\n  for (const m of filtered) {\n    const v = Number(m?.targetFt);\n    if (Number.isFinite(v)) max = Math.max(max, v);\n  }\n  if (max !== -Infinity) return max;\n  const t = getEnvTarget(profile, env);\n  return Number.isFinite(t) ? Number(t) : null;\n}\n","// Geodata builders and exporters for poles and spans\n// Exports: buildGeoJSON, exportGeoJSON, exportKML, exportKMZ, exportShapefile (optional)\n\nimport JSZip from \"jszip\";\n\n/**\n * @typedef {{ type: 'FeatureCollection', features: any[] }} FeatureCollection\n */\n\n/**\n * @param {any} v\n * @returns {number|undefined}\n */\nfunction asNumber(v) {\n  const n = typeof v === \"number\" ? v : Number(v);\n  return Number.isFinite(n) ? n : undefined;\n}\n\n/**\n * Helper function to create pole feature properties\n * @param {any} pole\n * @param {any} job\n * @returns {Record<string, any>}\n */\nfunction createPoleProperties(pole, job) {\n  /** @type {Record<string, any>} */\n  const props = {\n    id: pole.id || \"\",\n    jobId: pole.jobId || job.id || \"\",\n    status: pole.status || \"draft\",\n    height: pole.height ?? \"\",\n    poleClass: pole.poleClass ?? \"\",\n    powerHeight: pole.powerHeight ?? \"\",\n    voltage: pole.voltage ?? \"\",\n    hasTransformer: !!pole.hasTransformer,\n    spanDistance: pole.spanDistance ?? \"\",\n    adjacentPoleHeight: pole.adjacentPoleHeight ?? \"\",\n    attachmentType: pole.attachmentType || \"communication\",\n    timestamp: pole.timestamp || \"\",\n    commCompany: job.commCompany || \"\",\n    incomingBearingDeg: pole.incomingBearingDeg ?? \"\",\n    outgoingBearingDeg: pole.outgoingBearingDeg ?? \"\",\n    PULL_ft: pole.PULL_ft ?? \"\",\n  };\n\n  // Add optional asBuilt fields\n  if (pole.asBuilt?.attachHeight != null)\n    props.asBuiltAttach = pole.asBuilt.attachHeight;\n  if (pole.asBuilt?.powerHeight != null)\n    props.asBuiltPower = pole.asBuilt.powerHeight;\n  if (pole._varianceIn != null) props.varianceIn = pole._varianceIn;\n  if (pole._variancePass != null) props.variancePass = pole._variancePass;\n\n  return props;\n}\n\n/**\n * Helper function to build coordinate index from poles\n * @param {any[]} poles\n * @returns {Map<string, [number, number]>}\n */\nfunction buildCoordinateIndex(poles) {\n  const coordIndex = new Map();\n  for (const p of poles) {\n    const lat = asNumber(p.latitude);\n    const lon = asNumber(p.longitude);\n    if (Number.isFinite(lat) && Number.isFinite(lon) && p.id) {\n      coordIndex.set(String(p.id), [lon, lat]);\n    }\n  }\n  return coordIndex;\n}\n\n/**\n * @param {{ poles?: any[], spans?: any[], job?: any }} [input]\n * @returns {FeatureCollection}\n */\nexport function buildGeoJSON(input = {}) {\n  const {\n    poles = [],\n    spans = [],\n    job = {},\n  } = /** @type {{ poles?: any[], spans?: any[], job?: any }} */ (input);\n  /** @type {any[]} */\n  const features = [];\n\n  // Poles as points\n  for (const p of poles) {\n    const lat = asNumber(p.latitude);\n    const lon = asNumber(p.longitude);\n    if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;\n\n    const props = createPoleProperties(p, job);\n    features.push({\n      type: \"Feature\",\n      properties: props,\n      geometry: { type: \"Point\", coordinates: [lon, lat] },\n    });\n  }\n\n  // Spans as LineStrings (only if both endpoints are known)\n  const coordIndex = buildCoordinateIndex(poles);\n  for (const s of spans) {\n    const a = s.fromId != null ? coordIndex.get(String(s.fromId)) : undefined;\n    const b = s.toId != null ? coordIndex.get(String(s.toId)) : undefined;\n    if (!a || !b) continue;\n\n    const props = {\n      id: s.id || \"\",\n      jobId: job.id || \"\",\n      lengthFt: s.length ?? \"\",\n      proposedAttach: s.proposedAttach ?? \"\",\n      environment: s.environment || \"\",\n      incomingBearingDeg: s.incomingBearingDeg ?? \"\",\n      outgoingBearingDeg: s.outgoingBearingDeg ?? \"\",\n      PULL_ft: s.PULL_ft ?? \"\",\n    };\n    features.push({\n      type: \"Feature\",\n      properties: props,\n      geometry: { type: \"LineString\", coordinates: [a, b] },\n    });\n  }\n\n  return { type: \"FeatureCollection\", features };\n}\n\n/**\n * @param {string} filename\n * @param {string} text\n * @param {string} [type]\n */\nexport function downloadText(\n  filename,\n  text,\n  type = \"application/octet-stream\",\n) {\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") {\n    throw new Error(\"downloadText can only run in a browser environment.\");\n  }\n  const blob = new Blob([text], { type });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = filename;\n  a.click();\n  URL.revokeObjectURL(url);\n}\n\n/**\n * @param {FeatureCollection} fc\n * @param {string} [filename]\n */\nexport function exportGeoJSON(fc, filename = \"geodata.geojson\") {\n  downloadText(filename, JSON.stringify(fc, null, 2), \"application/geo+json\");\n}\n\n/**\n * @param {FeatureCollection} fc\n * @param {string} [filename]\n */\nexport async function exportKML(fc, filename = \"geodata.kml\") {\n  try {\n    const mod = await import(\"tokml\");\n    const tokml = mod.default ?? mod;\n    const kml = tokml(fc, {\n      documentName: \"PolePlan Pro\",\n      name: \"id\",\n      description: \"jobId\",\n    });\n    downloadText(filename, kml, \"application/vnd.google-earth.kml+xml\");\n  } catch (e) {\n    console.error(\"Error exporting KML, falling back to GeoJSON\", e);\n    exportGeoJSON(fc, filename.replace(/\\.kml$/, \".geojson\"));\n  }\n}\n\n/**\n * @param {FeatureCollection} fc\n * @param {string} [filename]\n */\nexport async function exportKMZ(fc, filename = \"geodata.kmz\") {\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") {\n    console.warn(\"KMZ export is browser-only; falling back to GeoJSON.\");\n    return exportGeoJSON(fc, filename.replace(/\\.kmz$/, \".geojson\"));\n  }\n  try {\n    const mod = await import(\"tokml\");\n    const tokml = mod.default ?? mod;\n    const kml = tokml(fc, {\n      documentName: \"PolePlan Pro\",\n      name: \"id\",\n      description: \"jobId\",\n    });\n    const zip = new JSZip();\n    zip.file(\"doc.kml\", kml);\n    const blob = await zip.generateAsync({ type: \"blob\" });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = filename;\n    a.click();\n    URL.revokeObjectURL(url);\n  } catch (e) {\n    console.error(\"Error exporting KMZ, falling back to GeoJSON\", e);\n    exportGeoJSON(fc, filename.replace(/\\.kmz$/, \".geojson\"));\n  }\n}\n\n// Shapefile export as an optional capability\n/**\n * @param {FeatureCollection} fc\n * @param {string} [filename]\n * @param {boolean} [autoDownload]\n */\nexport async function exportShapefile(\n  fc,\n  filename = \"geodata-shapefile.zip\",\n  autoDownload = true,\n) {\n  const featureCollection = {\n    type: \"FeatureCollection\",\n    features: fc.features || [],\n  };\n\n  const options = {\n    folder: \"poleplanwizard\",\n    types: { point: \"poles\", line: \"spans\", polygon: \"areas\" },\n  };\n\n  try {\n    const shpwrite = await loadShpWriteFromCDN();\n    if (!shpwrite) throw new Error(\"shpwrite not available\");\n\n    if (autoDownload) {\n      shpwrite.download(featureCollection, options);\n      return new Blob([JSON.stringify(featureCollection)], {\n        type: \"application/json\",\n      });\n    }\n\n    const base64 = shpwrite.zip(featureCollection, options);\n    const binary = atob(base64);\n    const len = binary.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);\n    return new Blob([bytes], { type: \"application/zip\" });\n  } catch (e) {\n    console.warn(\"Shapefile export unavailable; falling back to GeoJSON.\", e);\n    if (autoDownload) exportGeoJSON(fc, filename.replace(/\\.zip$/, \".geojson\"));\n    return new Blob([JSON.stringify(fc)], { type: \"application/json\" });\n  }\n}\n\nasync function loadShpWriteFromCDN() {\n  if (typeof window === \"undefined\") return undefined;\n  // @ts-ignore\n  if (window.shpwrite) return window.shpwrite;\n  const cdns = [\n    \"https://unpkg.com/@mapbox/shp-write@0.4.3/dist/shpwrite.js\",\n    \"https://cdn.jsdelivr.net/npm/@mapbox/shp-write@0.4.3/dist/shpwrite.js\",\n  ];\n  let lastError;\n  for (const url of cdns) {\n    try {\n      // Load with safer attributes; integrity omitted because upstream doesn't publish SRI\n      await new Promise((resolve, reject) => {\n        const s = document.createElement(\"script\");\n        s.src = url;\n        s.async = true;\n        s.referrerPolicy = \"no-referrer\";\n        s.crossOrigin = \"anonymous\";\n        s.onload = () => resolve(undefined);\n        s.onerror = () =>\n          reject(new Error(\"Failed to load shpwrite from CDN: \" + url));\n        document.head.appendChild(s);\n      });\n      // @ts-ignore\n      if (window.shpwrite) return window.shpwrite;\n    } catch (e) {\n      lastError = e;\n    }\n  }\n  throw lastError || new Error(\"Failed to load shpwrite from all CDNs\");\n}\n"],"file":"assets/app-geodata-OF3I9fsg.js"}