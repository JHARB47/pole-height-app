{"version":3,"mappings":"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","names":["EXPORT_PRESETS","formatNumber","n","buildCSV","rows","headers","lines","h","_a","polesToCSV","poles","p","buildPolesCSV","spansToCSV","spans","s","buildSpansCSV","existingLinesToCSV","l","buildExistingLinesCSV","toGeoJSON","existingLines","features","c","buildGeoJSON","input","buildKML","name","esc","v","b","buildFirstEnergyJointUseCSV","cachedMidspans","job","MAPPING_PRESETS","importGeospatialFile","file","parseKML","parseKMZ","parseShapefile","text","kmlToGeoJSON","__vitePreload","dom","fc","normalizeGeoJSON","zip","__vite_default__","kmlEntry","f","kmlText","ab","shp","geojson","geo","g","splitFeaturesByGeometry","others","getAttributeKeys","feature","mapGeoJSONToAppData","config","result","getProp","_c","_b","_f","_e","_d","getNumber","truthy","_g","estimateLengthFromGeometry","type","height","numberOrEmpty","obj","key","coerceNumber","geom","segments","arr","toRad","d","Rm","havSeg","lon1","lat1","lon2","lat2","dLat","dLon","a","meters","coords","i","raw","negative","fi","feet","inches","val","signMultiplier","signed","parseExistingLinesCSV","csvText","lineMapping","parsed","Papa","row","get","fallback","k","heightRaw","heightNum","parsePolesCSV","poleMapping","num","parseSpansCSV","spanMapping","parsePolesCSVValidated","mod","errors","data","parseSpansCSVValidated"],"ignoreList":[],"sources":["../../src/utils/exporters.js","../../src/utils/importers.js"],"sourcesContent":["// @ts-nocheck\n// Export utilities for interoperability with external tools\n// Provides CSV, GeoJSON, and KML exports for poles, spans, and existing lines.\n\nexport const EXPORT_PRESETS = [\n  { label: \"Generic (CSV/GeoJSON/KML)\", value: \"generic\" },\n  { label: \"ArcGIS (example)\", value: \"arcgis\" },\n  { label: \"ikeGPS (example)\", value: \"ikegps\" },\n  { label: \"Katapult Pro (example)\", value: \"katapultPro\" },\n  { label: \"FirstEnergy Joint-Use (example)\", value: \"firstEnergy\" },\n];\n\nexport function sanitizeFilename(name) {\n  // Convert to lower-kebab-case and strip illegal characters\n  const cleaned = String(name || \"\")\n    .toLowerCase()\n    .replace(/[\\\\/:*?\"<>|]+/g, \" \") // illegal -> space\n    .replace(/[^a-z0-9\\s-]+/g, \"\") // drop other punctuation\n    .trim()\n    .replace(/\\s+/g, \"-\")\n    .replace(/-+/g, \"-\")\n    .replace(/^-+|-+$/g, \"\")\n    .slice(0, 120);\n  return cleaned || \"export\";\n}\n\nfunction formatNumber(n) {\n  return Number.isFinite(n) ? Number(n.toFixed(3)) : \"\";\n}\n\nexport function addBOM(str) {\n  // Tests expect a string with a leading BOM character\n  return \"\\uFEFF\" + String(str ?? \"\");\n}\n\nfunction buildCSV({ rows, headers }) {\n  const lines = [headers.join(\",\")];\n  for (const r of rows) {\n    lines.push(headers.map((h) => r[h] ?? \"\").join(\",\"));\n  }\n  return lines.join(\"\\n\");\n}\n\nfunction polesToCSV(poles = []) {\n  const headers = [\n    \"id\",\n    \"label\",\n    \"latitude\",\n    \"longitude\",\n    \"height_ft\",\n    \"class\",\n    \"attach_height_ft\",\n    \"bearing_deg\",\n    \"pull_ft\",\n    \"notes\",\n  ];\n  const rows = poles.map((p) => ({\n    id: p.id,\n    label: p.label,\n    latitude: formatNumber(p.lat),\n    longitude: formatNumber(p.lng),\n    height_ft: formatNumber(p.heightFt),\n    class: p.class || \"\",\n    attach_height_ft: formatNumber(p.attachHeightFt),\n    bearing_deg: formatNumber(p.bearingDeg),\n    pull_ft: formatNumber(p.pullFt),\n    notes: p.notes || \"\",\n  }));\n  return buildCSV({ rows, headers });\n}\n\n// Named export aliases expected by tests\nexport function buildPolesCSV(poles = []) {\n  return polesToCSV(poles);\n}\n\nfunction spansToCSV(spans = []) {\n  const headers = [\n    \"id\",\n    \"from_pole_id\",\n    \"to_pole_id\",\n    \"length_ft\",\n    \"sag_ft\",\n    \"midspan_height_ft\",\n  ];\n  const rows = spans.map((s) => ({\n    id: s.id,\n    from_pole_id: s.fromPoleId,\n    to_pole_id: s.toPoleId,\n    length_ft: formatNumber(s.lengthFt),\n    sag_ft: formatNumber(s.sagFt),\n    midspan_height_ft: formatNumber(s.midspanHeightFt),\n  }));\n  return buildCSV({ rows, headers });\n}\n\nexport function buildSpansCSV(spans = []) {\n  return spansToCSV(spans);\n}\n\nfunction existingLinesToCSV(lines = []) {\n  const headers = [\"id\", \"type\", \"latitude\", \"longitude\", \"height_ft\", \"notes\"];\n  const rows = lines.map((l) => ({\n    id: l.id,\n    type: l.type || \"\",\n    latitude: formatNumber(l.lat),\n    longitude: formatNumber(l.lng),\n    height_ft: formatNumber(l.heightFt),\n    notes: l.notes || \"\",\n  }));\n  return buildCSV({ rows, headers });\n}\n\nexport function buildExistingLinesCSV(lines = []) {\n  return existingLinesToCSV(lines);\n}\n\nfunction toGeoJSON({ poles = [], spans = [], existingLines = [] }) {\n  const features = [];\n  for (const p of poles) {\n    features.push({\n      type: \"Feature\",\n      geometry: { type: \"Point\", coordinates: [p.lng, p.lat] },\n      properties: {\n        id: p.id,\n        label: p.label,\n        height_ft: p.heightFt,\n        attach_height_ft: p.attachHeightFt,\n        bearing_deg: p.bearingDeg,\n        pull_ft: p.pullFt,\n      },\n    });\n  }\n  for (const s of spans) {\n    if (s.coordinates && s.coordinates.length === 2) {\n      features.push({\n        type: \"Feature\",\n        geometry: {\n          type: \"LineString\",\n          coordinates: s.coordinates.map((c) => [c.lng, c.lat]),\n        },\n        properties: {\n          id: s.id,\n          from: s.fromPoleId,\n          to: s.toPoleId,\n          length_ft: s.lengthFt,\n        },\n      });\n    }\n  }\n  for (const l of existingLines) {\n    features.push({\n      type: \"Feature\",\n      geometry: { type: \"Point\", coordinates: [l.lng, l.lat] },\n      properties: { id: l.id, type: l.type },\n    });\n  }\n  return { type: \"FeatureCollection\", features };\n}\n\nexport function buildGeoJSON(input = {}) {\n  return toGeoJSON(input);\n}\n\nexport function buildKML({ poles = [], spans = [], name = \"Export\" }) {\n  const esc = (v) =>\n    String(v ?? \"\").replace(\n      /[&<>]/g,\n      (c) => ({ \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\" })[c],\n    );\n  const lines = [\n    '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n    '<kml xmlns=\"http://www.opengis.net/kml/2.2\">',\n    `<Document><name>${esc(name)}</name>`,\n  ];\n  for (const p of poles) {\n    lines.push(\n      \"<Placemark>\",\n      `<name>${esc(p.label || p.id)}</name>`,\n      `<Point><coordinates>${p.lng},${p.lat},0</coordinates></Point>`,\n      \"</Placemark>\",\n    );\n  }\n  for (const s of spans) {\n    if (s.coordinates && s.coordinates.length === 2) {\n      const [a, b] = s.coordinates;\n      lines.push(\n        \"<Placemark>\",\n        `<name>Span ${esc(s.id)}</name>`,\n        `<LineString><coordinates>${a.lng},${a.lat},0 ${b.lng},${b.lat},0</coordinates></LineString>`,\n        \"</Placemark>\",\n      );\n    }\n  }\n  lines.push(\"</Document></kml>\");\n  return lines.join(\"\");\n}\nexport async function buildKMZ({\n  poles = [],\n  spans = [],\n  name = \"Export\",\n} = {}) {\n  const { default: JSZip } = await import(\"jszip\");\n  const zip = new JSZip();\n  const kml = buildKML({ poles, spans, name });\n  zip.file(\"doc.kml\", kml);\n  return zip.generateAsync({ type: \"blob\", compression: \"DEFLATE\" });\n}\n\nexport function buildFirstEnergyJointUseCSV({ cachedMidspans = [], job = {} }) {\n  const headers = [\n    \"job_name\",\n    \"span_id\",\n    \"length_ft\",\n    \"sag_ft\",\n    \"midspan_height_ft\",\n  ];\n  const rows = cachedMidspans.map((s) => ({\n    job_name: job.name || \"\",\n    span_id: s.id,\n    length_ft: formatNumber(s.lengthFt),\n    sag_ft: formatNumber(s.sagFt),\n    midspan_height_ft: formatNumber(s.midspanHeightFt),\n  }));\n  return buildCSV({ rows, headers });\n}\n\nexport function buildExportBundle({\n  poles = [],\n  spans = [],\n  existingLines = [],\n  preset = \"generic\",\n  job = { name: \"Export\", jobNumber: \"\" },\n  includeBOM = false,\n} = {}) {\n  const ts = new Date().toISOString().replace(/[:T]/g, \"-\").replace(/\\..+/, \"\");\n  const base = sanitizeFilename(\n    [job.jobNumber, job.name, ts].filter(Boolean).join(\"-\"),\n  );\n\n  const polesCSV = buildPolesCSV(poles);\n  const spansCSV = buildSpansCSV(spans);\n  const existingCSV = buildExistingLinesCSV(existingLines);\n\n  const files = {\n    [`${base}/poles.csv`]: includeBOM ? addBOM(polesCSV) : polesCSV,\n    [`${base}/spans.csv`]: includeBOM ? addBOM(spansCSV) : spansCSV,\n    [`${base}/existing_lines.csv`]: includeBOM\n      ? addBOM(existingCSV)\n      : existingCSV,\n    [`${base}/data.geojson`]: new Blob(\n      [JSON.stringify(buildGeoJSON({ poles, spans, existingLines }), null, 2)],\n      { type: \"application/geo+json\" },\n    ),\n    [`${base}/data.kml`]: new Blob([], {\n      type: \"application/vnd.google-earth.kml+xml\",\n    }), // placeholder; real KML in KMZ\n  };\n\n  if (preset === \"firstEnergy\" && spans.length) {\n    const feCsv = buildFirstEnergyJointUseCSV({ cachedMidspans: spans, job });\n    files[`${base}/firstenergy_jointuse.csv`] = includeBOM\n      ? addBOM(feCsv)\n      : feCsv;\n  }\n\n  return { base, files };\n}\n\nexport async function buildExportZip({\n  poles = [],\n  spans = [],\n  existingLines = [],\n  preset = \"generic\",\n  job = { name: \"Export\", jobNumber: \"\" },\n  includeBOM = false,\n  onProgress,\n} = {}) {\n  const { default: JSZip } = await import(\"jszip\");\n  const zip = new JSZip();\n  const { base, files } = buildExportBundle({\n    poles,\n    spans,\n    existingLines,\n    preset,\n    job,\n    includeBOM,\n  });\n  for (const [filePath, fileData] of Object.entries(files))\n    zip.file(filePath, fileData);\n  const kmzBlob = await buildKMZ({ poles, spans, name: job?.name || \"export\" });\n  zip.file(`${base}/export.kmz`, kmzBlob);\n  const blob = await zip.generateAsync(\n    { type: \"blob\", compression: \"DEFLATE\" },\n    (meta) => {\n      if (typeof onProgress === \"function\") {\n        try {\n          onProgress(meta.percent || 0);\n        } catch {\n          /* intentionally ignore progress errors */\n        }\n      }\n    },\n  );\n  return blob;\n}\n\nexport function downloadFile(\n  data,\n  filename,\n  mime = \"application/octet-stream\",\n) {\n  const blob = data instanceof Blob ? data : new Blob([data], { type: mime });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = filename;\n  document.body.appendChild(a);\n  a.click();\n  setTimeout(() => {\n    URL.revokeObjectURL(url);\n    a.remove();\n  }, 0);\n}\n\nexport async function downloadExportZip(opts = {}) {\n  const blob = await buildExportZip(opts);\n  const name = sanitizeFilename(\n    [opts?.job?.jobNumber, opts?.job?.name || \"export\"]\n      .filter(Boolean)\n      .join(\"-\"),\n  );\n  downloadFile(blob, `${name}-bundle.zip`, \"application/zip\");\n}\n","// @ts-nocheck\n// Geospatial import utilities: KML, KMZ, and Shapefile -> GeoJSON\nimport Papa from \"papaparse\";\n// Heavy libraries are lazy-loaded with dynamic imports to keep initial bundle small.\n\n// Common attribute mapping presets by provider/source (customize as needed)\nexport const MAPPING_PRESETS = [\n  {\n    label: \"Generic (id,height,class,length,attach)\",\n    value: \"generic\",\n    mapping: {\n      pole: {\n        id: \"id\",\n        height: \"height\",\n        class: \"class\",\n        powerHeight: \"power_ht\",\n        hasTransformer: \"xfmr\",\n        latitude: \"\",\n        longitude: \"\",\n      },\n      span: {\n        id: \"id\",\n        fromId: \"from_id\",\n        toId: \"to_id\",\n        length: \"length\",\n        proposedAttach: \"attach\",\n      },\n      line: {\n        type: \"type\",\n        height: \"height\",\n        company: \"company\",\n        makeReady: \"mr\",\n        makeReadyHeight: \"mr_height\",\n      },\n    },\n  },\n  {\n    label: \"FirstEnergy sample\",\n    value: \"firstEnergy\",\n    mapping: {\n      pole: {\n        id: \"POLE_ID\",\n        height: \"HGT_FT\",\n        class: \"CLASS\",\n        powerHeight: \"PWR_HT\",\n        hasTransformer: \"XFMR\",\n        latitude: \"\",\n        longitude: \"\",\n      },\n      span: {\n        id: \"SPAN_ID\",\n        fromId: \"FROM_ID\",\n        toId: \"TO_ID\",\n        length: \"SPAN_FT\",\n        proposedAttach: \"ATTACH_FT\",\n      },\n      line: {\n        type: \"TYPE\",\n        height: \"HGT_FT\",\n        company: \"COMPANY\",\n        makeReady: \"MR\",\n        makeReadyHeight: \"MR_HGT\",\n      },\n    },\n  },\n  // Example presets for common external tools. Field names vary by org/project;\n  // use Configure Mapping to tweak if your export uses different headers.\n  {\n    label: \"ArcGIS Hosted Feature Layer (example)\",\n    value: \"arcgis\",\n    mapping: {\n      // Points layer attributes (commonly exported alongside geometry)\n      pole: {\n        id: \"POLE_ID\",\n        height: \"HEIGHT_FT\",\n        class: \"CLASS\",\n        powerHeight: \"PWR_HT\",\n        hasTransformer: \"XFMR\",\n        latitude: \"LATITUDE\",\n        longitude: \"LONGITUDE\",\n      },\n      // Lines layer attributes (if a spans layer is present); length may be estimated from geometry if absent\n      span: {\n        id: \"SPAN_ID\",\n        fromId: \"FROM_ID\",\n        toId: \"TO_ID\",\n        length: \"SPAN_FT\",\n        proposedAttach: \"ATTACH_FT\",\n      },\n      // Existing line attachments captured as attributes on either layer\n      line: {\n        type: \"LINE_TYPE\",\n        height: \"LINE_HT\",\n        company: \"OWNER\",\n        makeReady: \"MAKE_READY\",\n        makeReadyHeight: \"NEW_HT\",\n      },\n    },\n  },\n  {\n    label: \"ikeGPS (example)\",\n    value: \"ikegps\",\n    mapping: {\n      // These reflect commonly used headers; adjust to your export as needed\n      pole: {\n        id: \"POLE_ID\",\n        height: \"POLE_HEIGHT_FT\",\n        class: \"POLE_CLASS\",\n        powerHeight: \"PRIMARY_HT_FT\",\n        hasTransformer: \"TRANSFORMER\",\n        latitude: \"LAT\",\n        longitude: \"LON\",\n      },\n      span: {\n        id: \"SPAN_ID\",\n        fromId: \"FROM_ID\",\n        toId: \"TO_ID\",\n        length: \"SPAN_FT\",\n        proposedAttach: \"ATTACH_FT\",\n      },\n      line: {\n        type: \"LINE_TYPE\",\n        height: \"LINE_HT\",\n        company: \"COMPANY\",\n        makeReady: \"MAKE_READY\",\n        makeReadyHeight: \"NEW_HT\",\n      },\n    },\n  },\n  {\n    label: \"Katapult Pro Maps (example)\",\n    value: \"katapultPro\",\n    mapping: {\n      // CSV/KMZ exports typically include a name/id and optional metadata columns\n      pole: {\n        id: \"ID\",\n        height: \"HEIGHT_FT\",\n        class: \"CLASS\",\n        powerHeight: \"PRIMARY_HT\",\n        hasTransformer: \"XFMR\",\n        latitude: \"LAT\",\n        longitude: \"LON\",\n      },\n      span: {\n        id: \"SPAN_ID\",\n        fromId: \"FROM_ID\",\n        toId: \"TO_ID\",\n        length: \"SPAN_FT\",\n        proposedAttach: \"ATTACH_FT\",\n      },\n      line: {\n        type: \"TYPE\",\n        height: \"HGT_FT\",\n        company: \"OWNER\",\n        makeReady: \"MAKE_READY\",\n        makeReadyHeight: \"NEW_HT\",\n      },\n    },\n  },\n  {\n    label: \"PSE sample\",\n    value: \"pse\",\n    mapping: {\n      pole: {\n        id: \"POLE\",\n        height: \"HEIGHT\",\n        class: \"CLASS\",\n        powerHeight: \"PRIMARY_HT\",\n        hasTransformer: \"TRANSFORMER\",\n        latitude: \"\",\n        longitude: \"\",\n      },\n      span: {\n        id: \"SPAN\",\n        fromId: \"FROM_POLE\",\n        toId: \"TO_POLE\",\n        length: \"LENGTH_FT\",\n        proposedAttach: \"PROPOSED_FT\",\n      },\n      line: {\n        type: \"LINE_TYPE\",\n        height: \"LINE_HT\",\n        company: \"OWNER\",\n        makeReady: \"MAKE_READY\",\n        makeReadyHeight: \"NEW_HT\",\n      },\n    },\n  },\n];\n\nexport async function importGeospatialFile(file) {\n  const name = (file?.name || \"\").toLowerCase();\n  if (name.endsWith(\".kml\")) return parseKML(await file.text());\n  if (name.endsWith(\".kmz\")) return parseKMZ(file);\n  if (name.endsWith(\".zip\") || name.endsWith(\".shp\") || name.endsWith(\".dbf\"))\n    return parseShapefile(file);\n  throw new Error(\n    \"Unsupported file format. Please provide KML, KMZ, or Shapefile (.zip).\",\n  );\n}\n\nexport async function parseKML(text) {\n  try {\n    const { kml: kmlToGeoJSON } = await import(\"@tmcw/togeojson\");\n    const dom = new DOMParser().parseFromString(text, \"text/xml\");\n    const fc = kmlToGeoJSON(dom);\n    return normalizeGeoJSON(fc);\n  } catch (e) {\n    console.error(\"Error parsing KML, dependency may be missing\", e);\n    throw new Error(\n      'KML parsing requires dependency \"@tmcw/togeojson\". Error: ' + e.message,\n    );\n  }\n}\n\nexport async function parseKMZ(file) {\n  try {\n    const JSZip = (await import(\"jszip\")).default;\n    const zip = await JSZip.loadAsync(file);\n    // Find first .kml in the zip\n    const kmlEntry = Object.values(zip.files).find((f) =>\n      f.name.toLowerCase().endsWith(\".kml\"),\n    );\n    if (!kmlEntry) throw new Error(\"KMZ missing KML file\");\n    const kmlText = await kmlEntry.async(\"text\");\n    return parseKML(kmlText);\n  } catch (e) {\n    console.error(\"Error parsing KMZ, dependency may be missing\", e);\n    throw new Error(\n      'KMZ parsing requires dependency \"jszip\". Error: ' + e.message,\n    );\n  }\n}\n\nexport async function parseShapefile(file) {\n  try {\n    // shpjs can handle a zip, ArrayBuffer, or URL; use file arrayBuffer\n    const ab = await file.arrayBuffer();\n    const shp = (await import(\"shpjs\")).default;\n    const geojson = await shp(ab);\n    return normalizeGeoJSON(geojson);\n  } catch (e) {\n    console.error(\"Error parsing shapefile, dependency may be missing\", e);\n    throw new Error(\n      'Shapefile parsing requires optional dependency \"shpjs\". Error: ' +\n        e.message,\n    );\n  }\n}\n\nfunction normalizeGeoJSON(geo) {\n  if (!geo) return { type: \"FeatureCollection\", features: [] };\n  if (geo.type === \"FeatureCollection\") return geo;\n  if (geo.type === \"Feature\")\n    return { type: \"FeatureCollection\", features: [geo] };\n  if (Array.isArray(geo)) {\n    // shpjs may return array of FCs -> merge\n    const features = geo.flatMap((g) => g?.features || []);\n    return { type: \"FeatureCollection\", features };\n  }\n  return { type: \"FeatureCollection\", features: [] };\n}\n\nexport function splitFeaturesByGeometry(fc) {\n  const poles = [];\n  const lines = [];\n  const others = [];\n  for (const f of fc.features || []) {\n    const g = f.geometry?.type;\n    if (g === \"Point\") poles.push(f);\n    else if (g === \"LineString\" || g === \"MultiLineString\") lines.push(f);\n    else others.push(f);\n  }\n  return { poles, lines, others };\n}\n\nexport function getAttributeKeys(feature) {\n  return Object.keys(feature?.properties || {});\n}\n\n// Map GeoJSON features to app data using a mapping config\n// config example:\n// {\n//   pole: { id: 'POLE_ID', height: 'HGT_FT', class: 'CLASS', powerHeight: 'PWR_HT', hasTransformer: 'XFORMER' },\n//   span: { id: 'SPAN_ID', fromId: 'FROM_POLE', toId: 'TO_POLE', length: 'LENGTH_FT', proposedAttach: 'ATTACH_FT' },\n//   line: { type: 'TYPE', height: 'HGT_FT', company: 'COMP', makeReady: 'MR', makeReadyHeight: 'MR_HGT' }\n// }\nexport function mapGeoJSONToAppData(fc, config) {\n  const { poles, lines } = splitFeaturesByGeometry(fc);\n  /** @type {{ poleTable: Array<any>, spanTable: Array<any>, existingLines: Array<any> }} */\n  const result = { poleTable: [], spanTable: [], existingLines: [] };\n\n  // Poles (points)\n  for (const f of poles) {\n    const p = f.properties || {};\n    const c = config?.pole || {};\n    result.poleTable.push({\n      id: getProp(p, c.id),\n      latitude: f.geometry?.coordinates?.[1] ?? null,\n      longitude: f.geometry?.coordinates?.[0] ?? null,\n      height: getNumber(p, c.height),\n      class: getProp(p, c.class),\n      powerHeight: getNumber(p, c.powerHeight),\n      hasTransformer: truthy(p, c.hasTransformer),\n    });\n  }\n\n  // Lines (aerial spans)\n  for (const f of lines) {\n    const p = f.properties || {};\n    const c = config?.span || {};\n    result.spanTable.push({\n      id: getProp(p, c.id),\n      fromId: getProp(p, c.fromId),\n      toId: getProp(p, c.toId),\n      length: getNumber(p, c.length) ?? estimateLengthFromGeometry(f),\n      proposedAttach: getNumber(p, c.proposedAttach),\n    });\n  }\n\n  // Existing comm/power lines as side table (optional), using point or line attrs\n  for (const f of [...poles, ...lines]) {\n    const p = f.properties || {};\n    const c = config?.line || {};\n    const type = getProp(p, c.type);\n    const height = getNumber(p, c.height);\n    if (!type && height == null) continue;\n    result.existingLines.push({\n      type: type || \"communication\",\n      height: height != null ? `${height}` : \"\",\n      companyName: getProp(p, c.company) || \"\",\n      makeReady: truthy(p, c.makeReady),\n      makeReadyHeight: numberOrEmpty(p, c.makeReadyHeight),\n    });\n  }\n\n  return result;\n}\n\nfunction getProp(obj, key) {\n  if (!key) return undefined;\n  // Use safe access without optional chaining to avoid parser/lint issues\n  return obj && Object.hasOwn(obj, key) ? obj[key] : undefined;\n}\nfunction getNumber(obj, key) {\n  if (!key) return undefined;\n  const v = obj?.[key];\n  const n = coerceNumber(v);\n  return Number.isFinite(n) ? n : undefined;\n}\nfunction numberOrEmpty(obj, key) {\n  const n = getNumber(obj, key);\n  return Number.isFinite(n) ? `${n}` : \"\";\n}\nfunction truthy(obj, key) {\n  if (!key) return false;\n  const v = obj?.[key];\n  if (typeof v === \"boolean\") return v;\n  if (typeof v === \"number\") return v !== 0;\n  if (typeof v === \"string\") return /^(y|yes|true|1)$/i.test(v.trim());\n  return false;\n}\nfunction estimateLengthFromGeometry(f) {\n  // Haversine sum over segments; coordinates are [lon, lat]\n  try {\n    const geom = f.geometry;\n    if (!geom) return undefined;\n    const segments = [];\n    if (geom.type === \"LineString\") {\n      segments.push(geom.coordinates);\n    } else if (geom.type === \"MultiLineString\") {\n      for (const arr of geom.coordinates || []) segments.push(arr);\n    } else {\n      return undefined;\n    }\n    const toRad = (d) => (d * Math.PI) / 180;\n    const Rm = 6371000; // Earth radius meters\n    const havSeg = (lon1, lat1, lon2, lat2) => {\n      const dLat = toRad(lat2 - lat1);\n      const dLon = toRad(lon2 - lon1);\n      const a =\n        Math.sin(dLat / 2) ** 2 +\n        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;\n      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      return Rm * c; // meters\n    };\n    let meters = 0;\n    for (const coords of segments) {\n      for (let i = 1; i < coords.length; i++) {\n        const [lon1, lat1] = coords[i - 1];\n        const [lon2, lat2] = coords[i];\n        meters += havSeg(lon1, lat1, lon2, lat2);\n      }\n    }\n    return meters * 3.28084; // ft\n  } catch {\n    return undefined;\n  }\n}\n\n// Robust numeric coercion for messy inputs like \"1,234.56 ft\", \"12'6\\\"\", \"40.1°\", \"(12.5)\"\nexport function coerceNumber(raw) {\n  if (raw == null) return undefined;\n  if (typeof raw === \"number\") return Number.isFinite(raw) ? raw : undefined;\n  let s = String(raw).trim();\n  if (!s) return undefined;\n  let negative = false;\n  if (s.startsWith(\"(\") && s.endsWith(\")\")) {\n    negative = true;\n    s = s.slice(1, -1).trim();\n  }\n  // Normalize quotes and remove degree symbol\n  s = s.replace(/[’′]/g, \"'\").replace(/[“”″]/g, '\"').replace(/°/g, \"\");\n  // Strip common units\n  s = s.replace(/\\b(ft|feet|m|meter|meters)\\b/gi, \"\");\n  // Remove whitespace\n  s = s.replace(/\\s+/g, \"\");\n  // Feet-inches pattern like 12'6\" -> 12.5\n  const fi = s.match(/^(-?\\d+)'(\\d+(?:\\.\\d+)?)\"?$/);\n  if (fi) {\n    const feet = parseFloat(fi[1]);\n    const inches = parseFloat(fi[2]);\n    const val = feet + inches / 12;\n    return negative ? -Math.abs(val) : val;\n  }\n  // Preserve leading sign for pattern checks\n  let signMultiplier = 1;\n  if (/^[+-]/.test(s)) {\n    signMultiplier = s[0] === \"-\" ? -1 : 1;\n    s = s.slice(1);\n  }\n  // Handle thousands separators and decimal marks\n  // Cases:\n  //  - 1,234.56 (US): remove commas\n  //  - 1.234,56 (EU): remove dots, replace comma with dot\n  //  - 1234,56 (EU): replace comma with dot\n  //  - 1 234,56 or 1 234.56: spaces already removed above\n  if (/^\\d{1,3}(,\\d{3})+(\\.\\d+)?$/.test(s)) {\n    // US style with thousands commas\n    s = s.replace(/,/g, \"\");\n  } else if (/^\\d{1,3}(\\.\\d{3})+(,\\d+)?$/.test(s)) {\n    // EU style with thousands dots\n    s = s.replace(/\\./g, \"\");\n    if (/,\\d+$/.test(s)) s = s.replace(\",\", \".\");\n  } else if (/^\\d+,\\d+$/.test(s)) {\n    // No thousands, decimal comma\n    s = s.replace(\",\", \".\");\n  } else {\n    // Remove stray thousands commas; leave dot as decimal\n    s = s.replace(/,(?=\\d{3}(\\D|$))/g, \"\");\n  }\n  // Strip stray quotes\n  s = s.replace(/[\"']/g, \"\");\n  const n = parseFloat(s);\n  if (!Number.isFinite(n)) return undefined;\n  const signed = n * signMultiplier;\n  const val = negative ? -Math.abs(signed) : signed;\n  return val;\n}\n\n// Simple CSV parser for existing lines: expects headers including fields matching mapping.line\nexport function parseExistingLinesCSV(csvText, lineMapping) {\n  const parsed = Papa.parse(csvText || \"\", {\n    header: true,\n    skipEmptyLines: \"greedy\",\n    dynamicTyping: false,\n  });\n  const rows = Array.isArray(parsed.data) ? parsed.data : [];\n  return rows.map((row) => {\n    const get = (key, fallback) => {\n      const k = key || fallback;\n      const v = k ? row[k] : \"\";\n      return typeof v === \"string\" ? v.trim() : v;\n    };\n    const heightRaw = get(lineMapping?.height, \"height\");\n    const heightNum = coerceNumber(heightRaw);\n    return {\n      type: get(lineMapping?.type, \"type\") || \"communication\",\n      height: Number.isFinite(heightNum)\n        ? String(heightNum)\n        : String(heightRaw || \"\"),\n      companyName: get(lineMapping?.company, \"company\") || \"\",\n      makeReady: /^(y|yes|true|1)$/i.test(\n        String(get(lineMapping?.makeReady, \"makeReady\") || \"\"),\n      ),\n      makeReadyHeight: String(\n        get(lineMapping?.makeReadyHeight, \"makeReadyHeight\") || \"\",\n      ),\n    };\n  });\n}\n\n// CSV parser for Poles table\nexport function parsePolesCSV(csvText, poleMapping) {\n  const parsed = Papa.parse(csvText || \"\", {\n    header: true,\n    skipEmptyLines: \"greedy\",\n    dynamicTyping: false,\n  });\n  const rows = Array.isArray(parsed.data) ? parsed.data : [];\n  return rows.map((row) => {\n    const get = (key, fallback) => {\n      const k = key || fallback;\n      const v = k ? row[k] : \"\";\n      return typeof v === \"string\" ? v.trim() : v;\n    };\n    const num = (key, fallback) => {\n      const raw = get(key, fallback);\n      if (raw === \"\" || raw == null) return undefined;\n      const n = coerceNumber(raw);\n      return Number.isFinite(n) ? n : undefined;\n    };\n    return {\n      id: String(get(poleMapping?.id, \"id\") || \"\"),\n      latitude: num(poleMapping?.latitude, \"latitude\") ?? null,\n      longitude: num(poleMapping?.longitude, \"longitude\") ?? null,\n      height: num(poleMapping?.height, \"height\"),\n      class: get(poleMapping?.class, \"class\") || undefined,\n      powerHeight: num(poleMapping?.powerHeight, \"power_ht\"),\n      hasTransformer: /^(y|yes|true|1)$/i.test(\n        String(get(poleMapping?.hasTransformer, \"xfmr\") || \"\"),\n      ),\n    };\n  });\n}\n\n// CSV parser for Spans table\nexport function parseSpansCSV(csvText, spanMapping) {\n  const parsed = Papa.parse(csvText || \"\", {\n    header: true,\n    skipEmptyLines: \"greedy\",\n    dynamicTyping: false,\n  });\n  const rows = Array.isArray(parsed.data) ? parsed.data : [];\n  return rows.map((row) => {\n    const get = (key, fallback) => {\n      const k = key || fallback;\n      const v = k ? row[k] : \"\";\n      return typeof v === \"string\" ? v.trim() : v;\n    };\n    const num = (key, fallback) => {\n      const raw = get(key, fallback);\n      if (raw === \"\" || raw == null) return undefined;\n      const n = coerceNumber(raw);\n      return Number.isFinite(n) ? n : undefined;\n    };\n    return {\n      id: String(get(spanMapping?.id, \"id\") || \"\"),\n      fromId: String(get(spanMapping?.fromId, \"from_id\") || \"\"),\n      toId: String(get(spanMapping?.toId, \"to_id\") || \"\"),\n      length: num(spanMapping?.length, \"length\"),\n      proposedAttach: num(spanMapping?.proposedAttach, \"attach\"),\n    };\n  });\n}\n\n// Validation enhanced helpers (non-breaking additive API). They return\n// { data, errors } where data is the validated list (may be subset if invalid rows filtered).\n// zod is optional; if not installed these simply wrap the original parse results.\nexport async function parsePolesCSVValidated(csvText, poleMapping) {\n  const rows = parsePolesCSV(csvText, poleMapping);\n  try {\n    const mod = await import(\"./validation.js\");\n    if (mod && typeof mod.validatePoles === \"function\") {\n      const { errors, data } = mod.validatePoles(rows);\n      return { data, errors };\n    }\n  } catch {\n    // optional dependency missing; fall through\n  }\n  return { data: rows, errors: [] };\n}\n\nexport async function parseSpansCSVValidated(csvText, spanMapping) {\n  const rows = parseSpansCSV(csvText, spanMapping);\n  try {\n    const mod = await import(\"./validation.js\");\n    if (mod && typeof mod.validateSpans === \"function\") {\n      const { errors, data } = mod.validateSpans(rows);\n      return { data, errors };\n    }\n  } catch {\n    // optional dependency missing\n  }\n  return { data: rows, errors: [] };\n}\n\n// (No helper needed; ESM import above)\n"],"file":"assets/app-io-D6-Ks0MZ.js"}