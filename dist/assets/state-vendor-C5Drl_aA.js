const j=t=>{let r;const n=new Set,s=(a,b)=>{const h=typeof a=="function"?a(r):a;if(!Object.is(h,r)){const p=r;r=(b!=null?b:typeof h!="object"||h===null)?h:Object.assign({},r,h),n.forEach(m=>m(r,p))}},o=()=>r,l={setState:s,getState:o,getInitialState:()=>f,subscribe:a=>(n.add(a),()=>n.delete(a))},f=r=t(s,o,l);return l},M=(t=>t?j(t):j);function H(t,r){let n;try{n=t()}catch{return}return{getItem:o=>{var e;const d=f=>f===null?null:JSON.parse(f,void 0),l=(e=n.getItem(o))!=null?e:null;return l instanceof Promise?l.then(d):d(l)},setItem:(o,e)=>n.setItem(o,JSON.stringify(e,void 0)),removeItem:o=>n.removeItem(o)}}const I=t=>r=>{try{const n=t(r);return n instanceof Promise?n:{then(s){return I(s)(n)},catch(s){return this}}}catch(n){return{then(s){return this},catch(s){return I(s)(n)}}}},E=(t,r)=>(n,s,o)=>{let e={storage:H(()=>localStorage),partialize:i=>i,version:0,merge:(i,g)=>({...g,...i}),...r},d=!1;const l=new Set,f=new Set;let a=e.storage;if(!a)return t((...i)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),n(...i)},s,o);const b=()=>{const i=e.partialize({...s()});return a.setItem(e.name,{state:i,version:e.version})},h=o.setState;o.setState=(i,g)=>(h(i,g),b());const p=t((...i)=>(n(...i),b()),s,o);o.getInitialState=()=>p;let m;const O=()=>{var i,g;if(!a)return;d=!1,l.forEach(c=>{var u;return c((u=s())!=null?u:p)});const y=((g=e.onRehydrateStorage)==null?void 0:g.call(e,(i=s())!=null?i:p))||void 0;return I(a.getItem.bind(a))(e.name).then(c=>{if(c)if(typeof c.version=="number"&&c.version!==e.version){if(e.migrate){const u=e.migrate(c.state,c.version);return u instanceof Promise?u.then(S=>[!0,S]):[!0,u]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,c.state];return[!1,void 0]}).then(c=>{var u;const[S,_]=c;if(m=e.merge(_,(u=s())!=null?u:p),n(m,!0),S)return b()}).then(()=>{y==null||y(m,void 0),m=s(),d=!0,f.forEach(c=>c(m))}).catch(c=>{y==null||y(void 0,c)})};return o.persist={setOptions:i=>{e={...e,...i},i.storage&&(a=i.storage)},clearStorage:()=>{a==null||a.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>O(),hasHydrated:()=>d,onHydrate:i=>(l.add(i),()=>{l.delete(i)}),onFinishHydration:i=>(f.add(i),()=>{f.delete(i)})},e.skipHydration||O(),m||p},R=E,v=t=>Symbol.iterator in t,w=t=>"entries"in t,x=(t,r)=>{const n=t instanceof Map?t:new Map(t.entries()),s=r instanceof Map?r:new Map(r.entries());if(n.size!==s.size)return!1;for(const[o,e]of n)if(!s.has(o)||!Object.is(e,s.get(o)))return!1;return!0},P=(t,r)=>{const n=t[Symbol.iterator](),s=r[Symbol.iterator]();let o=n.next(),e=s.next();for(;!o.done&&!e.done;){if(!Object.is(o.value,e.value))return!1;o=n.next(),e=s.next()}return!!o.done&&!!e.done};function k(t,r){return Object.is(t,r)?!0:typeof t!="object"||t===null||typeof r!="object"||r===null||Object.getPrototypeOf(t)!==Object.getPrototypeOf(r)?!1:v(t)&&v(r)?w(t)&&w(r)?x(t,r):P(t,r):x({entries:()=>Object.entries(t)},{entries:()=>Object.entries(r)})}export{M as a,H as c,R as p,k as s};
//# sourceMappingURL=state-vendor-C5Drl_aA.js.map
